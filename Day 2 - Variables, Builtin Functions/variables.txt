âœ… 1. Variables en Python.

â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘            OBJETO                â•‘
â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£
â•‘ Identidad (id)                   â•‘
â•‘ Tipo/clase                       â•‘
â•‘ Valor interno                    â•‘
â•‘ Atributos                        â•‘
â•‘ MÃ©todos                          â•‘
â•‘ MÃ©todos mÃ¡gicos (dunder)         â•‘
â•‘ Diccionario interno (__dict__)   â•‘
â•‘ Slots internos (si existen)      â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

Todo en Python es un objeto: nÃºmeros, funciones, mÃ³dulos, clases, tipos, listas, excepciones, etc.

obj = [1, 2, 3]

print("Tipo:", type(obj))   #type() â†’ clase del objeto
Tipo: <class 'list'>

print("ID:", id(obj))       #id() â†’ direcciÃ³n en memoria (o referencia Ãºnica)
ID: 140045331029264

print("Valor interno:", obj) #Valor interno â†’ lo que contiene el objeto
Valor interno: [1, 2, 3]

print(dir(obj))             #Esto muestra todos los atributos, mÃ©todos mÃ¡gicos, mÃ©todos disponibles, etc.
['__add__', '__class__', '__contains__', ..., 'append', 'clear', 'copy', 'extend', ...]

print(obj.__dict__)         #Muchos objetos en Python tienen un diccionario interno donde guardan atributos. Esto es normal: las listas optimizan memoria y no tienen __dict__.
AttributeError: 'list' object has no attribute '__dict__'

help(obj)                   #Esto muestra toda la documentaciÃ³n oficial del tipo.

print(obj.__class__)        # Para ver la clase del objeto, indican que las listas heredan de object.

print(obj.__class__.mro())  #Method Resolution Order (orden de herencia)
[<class 'list'>, <class 'object'>]

import inspect
print(inspect.getmembers(obj)) #muestra todo: mÃ©todos, atributos, valores internos, funciones heredadas, funciones mÃ¡gicas

# Inspeccionar un objeto totalmente.
import inspect

def inspeccionar(o):
    print("=== INSPECCIÃ“N DE OBJETO ===")
    print("Tipo:", type(o))
    print("ID:", id(o))
    print("Valor interno:", repr(o))
    print("\nAtributos y mÃ©todos:")
    print(dir(o))
    print("\nAtributos del objeto (si existen):")
    print(getattr(o, "__dict__", "No tiene __dict__"))
    print("\nMRO (JerarquÃ­a):")
    print(type(o).mro())
    print("\nMÃ©todos:")
    print([m for m in dir(o) if callable(getattr(o, m))])
    print("\nAtributos no llamables:")
    print([a for a in dir(o) if not callable(getattr(o, a))])

obj = [1, 2, 3]
inspeccionar(obj)

âœ… 2. En Python, una variable es simplemente un nombre que referencia un objeto en memoria.

    âˆ™ Se crea un objeto de tipo int con valor 10.
    âˆ™ El nombre x apunta a ese objeto.

         x = 10

âœ… 3. Variables y mapeo en memoria 

x = 10
y = 10
x = y
x = 20

Analicemos paso por paso:

x = 10
x â†’ objeto 10 // x contiene referencia (apuntan) a objeto 10

y = 10
Como los enteros pequeÃ±os estÃ¡n internados (â€œinterningâ€), Python reutiliza el mismo objeto:
y â†’ objeto 10 // x e y contienen referencia (apuntan) al mismo objeto 10

x = 20
Ahora x contiene referencia (apunta) a un nuevo objeto 20, y sigue apuntando a 10.
x â†’ 20
y â†’ 10

âœ… 4. Tipado dinÃ¡mico y fuerte en Python

âœ… 5. Variables como argumentos de funciones (pass-by-object-reference).

    âˆ™ Se pasan las referencias a los objetos, no copias.
    âˆ™ Pero no se pasa la variable, es decir, dentro de la funciÃ³n NO puedes cambiar quÃ© variable externa apunta a un objeto.

-Objeto inmutable (int, str, tuple)

    def incrementar(n):
        n = n + 1
        print("Dentro:", n)

    x = 10
    incrementar(x)
    print("Fuera:", x)

Salida
Dentro: 11
Fuera: 10

ExplicaciÃ³n:

    âˆ™n recibe la referencia al objeto 10. Luego n = n + 1 crea un nuevo objeto 11. x no cambia porque los enteros son inmutables.

-Objeto mutable (list, dict, set)
    def agregar(lista):
        lista.append(4)
        print("Dentro:", lista)

    x = [1, 2, 3]
    agregar(x)
    print("Fuera:", x)

Salida:
Dentro: [1, 2, 3, 4]
Fuera: [1, 2, 3, 4]

ExplicaciÃ³n:

    âˆ™lista apunta al mismo objeto que x.
    âˆ™.append() modifica el objeto, no la referencia.
    âˆ™Por eso el cambio se ve fuera de la funciÃ³n.

######################################################################################################################################################
Primitivos u Objetos. El Modelo de CPython ğŸ§ 

En Python, no existen los tipos de datos primitivos en el sentido estricto (como en C o Java). Todos los tipos de datos son objetos.

En CPython, la memoria se divide principalmente en dos Ã¡reas: el Stack (pila) y el Heap (montÃ­culo). 
Vamos a realizar el mapeo tÃ©cnico de quÃ© sucede exactamente cuando ejecutas una instrucciÃ³n simple como x = 5.

El Mapeo de Memoria: Stack vs. Heap ğŸ› ï¸

1. En el Stack (Pila de Llamadas)
El Stack almacena los marcos de referencia (frames). Cuando declaras x, no se guarda el nÃºmero 5 ahÃ­. 
Se guarda una referencia (un puntero de 8 bytes en sistemas de 64 bits).

    Variable: x
    Contenido: 0x10A2 (Una direcciÃ³n de memoria que apunta al Heap).

2. En el Heap (MontÃ­culo de Objetos)
AquÃ­ es donde reside el objeto real. En la direcciÃ³n 0x10A2, no solo hay un "5", hay una estructura compleja de C llamada PyLongObject (para los enteros).

AnatomÃ­a de un Objeto Entero en el Heap ğŸ§¬

Si hiciÃ©ramos una "autopsia" al objeto en la direcciÃ³n 0x10A2, verÃ­amos estos campos (simplificando la estructura de CPython):

Campo en Memoria            Nombre TÃ©cnico              DescripciÃ³n
Cabecera 1                  ,ob_refcnt,                 "Contador de Referencias: Si x = 5, aquÃ­ habrÃ¡ un 1. Si haces y = x, subirÃ¡ a 2."
Cabecera 2,                 ob_type,                    Puntero al Tipo: Un puntero a la direcciÃ³n de memoria de la clase int. AsÃ­ sabe Python que puede sumar este objeto.
Valor,                      ob_digit,                   "El valor real (en este caso, el binario para 5). En Python los enteros son de precisiÃ³n arbitraria, por lo que esta parte puede crecer."

Â¿Por quÃ© esto es relevante para el rendimiento? ğŸï¸

-IndirecciÃ³n: Cada vez que accedes a x, Python debe:
    -Ir al Stack para buscar la direcciÃ³n.
    -Saltar al Heap en esa direcciÃ³n.
    -Leer el ob_type para saber quÃ© operaciones estÃ¡n permitidas.
    -Finalmente, acceder al valor.
    -Esto explica por quÃ© Python es mÃ¡s lento que C (donde el 5 estarÃ­a directamente en el Stack).

-Inmutabilidad: Si haces x = x + 1, Python no cambia el valor en el Heap. Crea un nuevo objeto (por ejemplo en 0x20B4) con el valor 6, y actualiza la referencia en el Stack de x para que apunte a la nueva direcciÃ³n. El objeto viejo (5) reduce su ob_refcnt.

1. La estructura PyObject ğŸ—ï¸

En el nivel de C, todo objeto comienza con una estructura llamada PyObject. Esta es la "cabecera" que mencionamos. Si miramos el cÃ³digo fuente de Python, verÃ¡s algo como esto:
    - ob_refcnt (Reference Count): Un entero que lleva la cuenta de cuÃ¡ntas variables estÃ¡n apuntando a este objeto. Cuando llega a cero, el Garbage Collector libera la memoria.
    - ob_type: Un puntero a otro objeto que representa el tipo (por ejemplo, el objeto clase int). Esto es lo que le dice a Python que el objeto debe comportarse como un nÃºmero y no como una lista.

2. El fenÃ³meno del "Interning" (CachÃ© de objetos) ğŸ§ 

Ahora, volviendo a tu duda sobre por quÃ© 256 es el mismo objeto y 257 no, la respuesta reside en una optimizaciÃ³n del intÃ©rprete.
    -Enteros PequeÃ±os: Python asume que usarÃ¡s nÃºmeros pequeÃ±os muy seguido. Por eso, al arrancar, crea una matriz estÃ¡tica de objetos int para todos los nÃºmeros en el rango de -5 a 256.
    -ReutilizaciÃ³n: Cuando escribes a = 256, Python no crea un objeto nuevo; simplemente apunta a al objeto que ya existe en esa matriz global.
    -Nuevas Instancias: Para 257, Python generalmente crea un objeto nuevo en el heap cada vez que se asigna (fuera de optimizaciones especÃ­ficas del compilador de bloques de cÃ³digo).

El Ãrbol de Herencia de Tipos ğŸŒ³
Todos los tipos en Python derivan de una Ãºnica raÃ­z: la clase object

OBJECT
 â”œâ”€â”€ int
 â”‚    â””â”€â”€ bool (True, False)
 â”œâ”€â”€ float
 â”œâ”€â”€ complex
 â”œâ”€â”€ str
 â”œâ”€â”€ list
 â”œâ”€â”€ dict
 â”œâ”€â”€ set
 â””â”€â”€ tuple

 Una curiosidad tÃ©cnica: Â¿SabÃ­as que bool es una subclase de int? Por eso puedes hacer operaciones como True + True y obtener 2.

 3. MÃ©todos y Protocolos (Dunder Methods) ğŸ› ï¸
 Al ser objetos, todos tienen mÃ©todos. Se dividen principalmente en dos categorÃ­as:

CategorÃ­a               DescripciÃ³n                                                                 Ejemplos
MÃ©todos PÃºblicos        Acciones especÃ­ficas del tipo.                                           "list.append(), str.upper()"
MÃ©todos Dunder          Implementan protocolos del lenguaje (aritmÃ©tica, comparaciÃ³n).            __add__, __len__, __eq__"

Cuando tÃº escribes objeto.metodo(), Python inicia un proceso llamado Atribute Lookup. 
No importa si es un mÃ©todo pÃºblico o un Dunder; el mecanismo base es similar, pero el dunder suele activarse por "atajos" del intÃ©rprete.

1-El flujo de resoluciÃ³n:
    1-Instancia (__dict__): Python busca primero en el diccionario local del objeto. AquÃ­ suelen estar solo los datos (atributos como self.x), no los mÃ©todos.
    2-Clase (type(objeto)): Si no estÃ¡ en la instancia, Python salta al objeto Clase en el Heap. AquÃ­ es donde viven los mÃ©todos (las funciones que todos los objetos de ese tipo comparten).
    3-Herencia (MRO): Si no estÃ¡ en su clase, busca en sus padres siguiendo el Ã¡rbol de herencia hasta llegar a object.

2. MÃ©todos PÃºblicos: Despacho ExplÃ­cito
Cuando haces lista.append(x):
    -Python ve el punto (.).
    -Busca en la clase list el nombre append.
    -Encuentra una funciÃ³n.
    -El paso clave: Python convierte lista.append(x) en list.append(lista, x). Pasa automÃ¡ticamente la direcciÃ³n del objeto como el primer argumento: el famoso self.

3. Â¿QuÃ© es un mÃ©todo "Dunder"? : Despacho ImplÃ­cito (Slots)
El tÃ©rmino proviene de "Double Under" (doble guion bajo). 
No son mÃ©todos mÃ¡gicos, aunque a veces se les llame asÃ­ (magic methods); 
son simplemente hooks (ganchos) predefinidos que el intÃ©rprete de Python utiliza para ejecutar operaciones estÃ¡ndar.

AquÃ­ es donde Python se pone serio por rendimiento. Para no hacer una bÃºsqueda lenta en un diccionario cada vez que sumas 1 + 1, CPython utiliza Slots.

    -En el C-Level: El objeto PyTypeObject (la clase) tiene una estructura fija con "huecos" (slots) para los dunders mÃ¡s comunes (como tp_as_number para __add__).
    -El Camino Directo: Cuando escribes a + b, el intÃ©rprete no busca la cadena "__add__" en un diccionario. Va directamente al puntero de memoria del "slot" de suma en la estructura de la clase. Es casi tan rÃ¡pido como una llamada a funciÃ³n en C.

Cuando tÃº usas un operador como + o una funciÃ³n como len(), Python no sabe por sÃ­ solo cÃ³mo sumar o contar los elementos de un objeto que tÃº hayas creado. 
Lo que hace es delegar esa responsabilidad al objeto mismo preguntÃ¡ndole: "Â¿Tienes implementado el contrato para esta operaciÃ³n?" ğŸ¤

4. VisualizaciÃ³n del mapeo Stack-Heap con MÃ©todos
Si tenemos x = [1, 2]:
    -Stack: x -> 0xABC (DirecciÃ³n en el Heap).
    -Heap (Instancia 0xABC):
        ob_refcnt: 1
        ob_type: 0x999 (Puntero a la clase list).
        ob_item: Puntero a los datos [1, 2].
    -Heap (Clase list en 0x999):
        __add__: Puntero a cÃ³digo binario de suma.
        append: Puntero a cÃ³digo binario de inserciÃ³n.
        __len__: Puntero a cÃ³digo que lee el tamaÃ±o.

4. Los Protocolos: El "Contrato" de Python ğŸ“œ
En lugar de depender de una jerarquÃ­a de herencia rÃ­gida (como en Java), Python usa Duck Typing. Si tu objeto implementa el mÃ©todo dunder necesario, entonces "sigue el protocolo".
AquÃ­ tienes los protocolos mÃ¡s importantes:

Protocolo               MÃ©todo Dunder               AcciÃ³n que lo activa
AritmÃ©tico             "__add__(self, other)"       El operador +
RepresentaciÃ³n          __str__(self)               La funciÃ³n print() o str()
Contenedor             ,__len__(self),              La funciÃ³n len()
ComparaciÃ³n,            "__eq__(self, other)",      El operador ==
In-place,               "__iadd__(self, other)",    El operador +=

5. La diferencia entre + e += (Mutabilidad) ğŸ§ 
Retomando tu pregunta anterior sobre la memoria, aquÃ­ es donde los dunders revelan la verdad:

1. __add__ (Suma normal a + b): Por convenciÃ³n, este mÃ©todo debe crear un objeto nuevo y devolverlo. No debe modificar self. Por eso id(lista_a) cambia si haces lista_a = lista_a + [4].
2. __iadd__ (Suma in-place a += b): Este mÃ©todo estÃ¡ diseÃ±ado para modificar el objeto existente si es posible (como en las listas). Si el objeto es mutable, __iadd__ modifica self y lo devuelve, manteniendo el mismo id.

######################################################################################################################################################
1. La FunciÃ³n print(): La AnatomÃ­a de la Salida
La firma tÃ©cnica es: print(*objects, sep=' ', end='\n', file=sys.stdout, flush=False)

    -*objects (Argumentos posicionales): El asterisco significa que puedes pasar N objetos. Python llamarÃ¡ internamente a str(objeto) para cada uno antes de imprimirlos.
    -sep (Separador): Lo que se inyecta entre cada objeto. Por defecto es un espacio ' '.
    -end (Finalizador): Lo que se inyecta al final de la lÃ­nea. Por defecto es \n (salto de lÃ­nea). Si quieres imprimir en la misma lÃ­nea varias veces, cÃ¡mbialo a end=''.
    -file (El destino): Por defecto es sys.stdout (la pantalla). Pero aquÃ­ podrÃ­as pasar un archivo abierto. Dato Senior: print es solo un envoltorio elegante sobre el mÃ©todo .write() de cualquier objeto que se comporte como un archivo.
    -flush (Vaciado de bÃºfer): Normalmente, Python guarda los caracteres en memoria antes de mandarlos a la pantalla para ahorrar recursos. Si flush=True, obliga al sistema a mostrarlo ahora mismo. Vital para barras de carga.

