âœ… 1. Variables en Python.

â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘            OBJETO                â•‘
â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£
â•‘ Identidad (id)                   â•‘
â•‘ Tipo/clase                       â•‘
â•‘ Valor interno                    â•‘
â•‘ Atributos                        â•‘
â•‘ MÃ©todos                          â•‘
â•‘ MÃ©todos mÃ¡gicos (dunder)         â•‘
â•‘ Diccionario interno (__dict__)   â•‘
â•‘ Slots internos (si existen)      â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

Todo en Python es un objeto: nÃºmeros, funciones, mÃ³dulos, clases, tipos, listas, excepciones, etc.

obj = [1, 2, 3]

print("Tipo:", type(obj))   #type() â†’ clase del objeto
Tipo: <class 'list'>

print("ID:", id(obj))       #id() â†’ direcciÃ³n en memoria (o referencia Ãºnica)
ID: 140045331029264

print("Valor interno:", obj) #Valor interno â†’ lo que contiene el objeto
Valor interno: [1, 2, 3]

print(dir(obj))             #Esto muestra todos los atributos, mÃ©todos mÃ¡gicos, mÃ©todos disponibles, etc.
['__add__', '__class__', '__contains__', ..., 'append', 'clear', 'copy', 'extend', ...]

print(obj.__dict__)         #Muchos objetos en Python tienen un diccionario interno donde guardan atributos. Esto es normal: las listas optimizan memoria y no tienen __dict__.
AttributeError: 'list' object has no attribute '__dict__'

help(obj)                   #Esto muestra toda la documentaciÃ³n oficial del tipo.

print(obj.__class__)        # Para ver la clase del objeto, indican que las listas heredan de object.

print(obj.__class__.mro())  #Method Resolution Order (orden de herencia)
[<class 'list'>, <class 'object'>]

import inspect
print(inspect.getmembers(obj)) #muestra todo: mÃ©todos, atributos, valores internos, funciones heredadas, funciones mÃ¡gicas

# Inspeccionar un objeto totalmente.
import inspect

def inspeccionar(o):
    print("=== INSPECCIÃ“N DE OBJETO ===")
    print("Tipo:", type(o))
    print("ID:", id(o))
    print("Valor interno:", repr(o))
    print("\nAtributos y mÃ©todos:")
    print(dir(o))
    print("\nAtributos del objeto (si existen):")
    print(getattr(o, "__dict__", "No tiene __dict__"))
    print("\nMRO (JerarquÃ­a):")
    print(type(o).mro())
    print("\nMÃ©todos:")
    print([m for m in dir(o) if callable(getattr(o, m))])
    print("\nAtributos no llamables:")
    print([a for a in dir(o) if not callable(getattr(o, a))])

obj = [1, 2, 3]
inspeccionar(obj)

âœ… 2. En Python, una variable es simplemente un nombre que referencia un objeto en memoria.

    âˆ™ Se crea un objeto de tipo int con valor 10.
    âˆ™ El nombre x apunta a ese objeto.

         x = 10

âœ… 3. Variables y mapeo en memoria 

x = 10
y = 10
x = y
x = 20

Analicemos paso por paso:

x = 10
x â†’ objeto 10 // x contiene referencia (apuntan) a objeto 10

y = 10
Como los enteros pequeÃ±os estÃ¡n internados (â€œinterningâ€), Python reutiliza el mismo objeto:
y â†’ objeto 10 // x e y contienen referencia (apuntan) al mismo objeto 10

x = 20
Ahora x contiene referencia (apunta) a un nuevo objeto 20, y sigue apuntando a 10.
x â†’ 20
y â†’ 10

âœ… 4. Tipado dinÃ¡mico y fuerte en Python

âœ… 5. Variables como argumentos de funciones (pass-by-object-reference).

    âˆ™ Se pasan las referencias a los objetos, no copias.
    âˆ™ Pero no se pasa la variable, es decir, dentro de la funciÃ³n NO puedes cambiar quÃ© variable externa apunta a un objeto.

-Objeto inmutable (int, str, tuple)

    def incrementar(n):
        n = n + 1
        print("Dentro:", n)

    x = 10
    incrementar(x)
    print("Fuera:", x)

Salida
Dentro: 11
Fuera: 10

ExplicaciÃ³n:

    âˆ™n recibe la referencia al objeto 10. Luego n = n + 1 crea un nuevo objeto 11. x no cambia porque los enteros son inmutables.

-Objeto mutable (list, dict, set)
    def agregar(lista):
        lista.append(4)
        print("Dentro:", lista)

    x = [1, 2, 3]
    agregar(x)
    print("Fuera:", x)

Salida:
Dentro: [1, 2, 3, 4]
Fuera: [1, 2, 3, 4]

ExplicaciÃ³n:

    âˆ™lista apunta al mismo objeto que x.
    âˆ™.append() modifica el objeto, no la referencia.
    âˆ™Por eso el cambio se ve fuera de la funciÃ³n.

######################################################################################################################################################
Â¿Primitivos u Objetos? El Modelo de CPython ğŸ§ 

En Python, no existen los tipos de datos primitivos en el sentido estricto (como en C o Java). Todos los tipos de datos son objetos.
    -Cada variable es una referencia a un objeto en el heap. 
    -Incluso un simple entero como 5 tiene una cabecera de objeto (PyObject) que incluye un contador de referencias y un puntero a su tipo.

1. La estructura PyObject ğŸ—ï¸

En el nivel de C, todo objeto comienza con una estructura llamada PyObject. Esta es la "cabecera" que mencionamos. Si miramos el cÃ³digo fuente de Python, verÃ¡s algo como esto:
    - ob_refcnt (Reference Count): Un entero que lleva la cuenta de cuÃ¡ntas variables estÃ¡n apuntando a este objeto. Cuando llega a cero, el Garbage Collector libera la memoria.
    - ob_type: Un puntero a otro objeto que representa el tipo (por ejemplo, el objeto clase int). Esto es lo que le dice a Python que el objeto debe comportarse como un nÃºmero y no como una lista.

2. El fenÃ³meno del "Interning" (CachÃ© de objetos) ğŸ§ 

Ahora, volviendo a tu duda sobre por quÃ© 256 es el mismo objeto y 257 no, la respuesta reside en una optimizaciÃ³n del intÃ©rprete.
    -Enteros PequeÃ±os: Python asume que usarÃ¡s nÃºmeros pequeÃ±os muy seguido. Por eso, al arrancar, crea una matriz estÃ¡tica de objetos int para todos los nÃºmeros en el rango de -5 a 256.
    -ReutilizaciÃ³n: Cuando escribes a = 256, Python no crea un objeto nuevo; simplemente apunta a al objeto que ya existe en esa matriz global.
    -Nuevas Instancias: Para 257, Python generalmente crea un objeto nuevo en el heap cada vez que se asigna (fuera de optimizaciones especÃ­ficas del compilador de bloques de cÃ³digo).

El Ãrbol de Herencia de Tipos ğŸŒ³
Todos los tipos en Python derivan de una Ãºnica raÃ­z: la clase object

OBJECT
 â”œâ”€â”€ int
 â”‚    â””â”€â”€ bool (True, False)
 â”œâ”€â”€ float
 â”œâ”€â”€ complex
 â”œâ”€â”€ str
 â”œâ”€â”€ list
 â”œâ”€â”€ dict
 â”œâ”€â”€ set
 â””â”€â”€ tuple

 Una curiosidad tÃ©cnica: Â¿SabÃ­as que bool es una subclase de int? Por eso puedes hacer operaciones como True + True y obtener 2.

 3. MÃ©todos y Protocolos (Dunder Methods) ğŸ› ï¸
 Al ser objetos, todos tienen mÃ©todos. Se dividen principalmente en dos categorÃ­as:

CategorÃ­a               DescripciÃ³n                                                                 Ejemplos
MÃ©todos 
PÃºblicos                Acciones especÃ­ficas del tipo.                                           "list.append(), str.upper()"
MÃ©todos Dunder          Implementan protocolos del lenguaje (aritmÃ©tica, comparaciÃ³n).            __add__, __len__, __eq__"



