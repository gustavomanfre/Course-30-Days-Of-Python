Aqu√≠ tienes la explicaci√≥n detallada de la Pila de Ejecuci√≥n (Call Stack) en Python.

1. ¬øQu√© es el Stack realmente? (El Algoritmo LIFO)

Imagina una pila de platos sucios en un restaurante.
    El Algoritmo: Es LIFO (Last In, First Out - √öltimo en entrar, Primero en salir).
    Solo puedes poner un plato nuevo encima del anterior (PUSH).
    Solo puedes lavar (sacar) el plato que est√° arriba de todo (POP).

En Python, cada "plato" es un Frame (Marco de Ejecuci√≥n).
2. ¬øQu√© hay dentro de cada "Plato" (Frame)?

Cada vez que llamas a una funci√≥n, Python crea un Frame nuevo y lo pone en el tope de la pila. Ese Frame es un espacio aislado que contiene:
    Las Variables Locales (Nombres): Aqu√≠ est√°n los nombres que definiste dentro de la funci√≥n (ej: summation, nums, f).
    Las Referencias (Las Flechas): Aqu√≠ es donde entra tu duda. En el Stack NO se guardan los objetos.
        Si tienes x = [1, 2], el Stack guarda el nombre x y una direcci√≥n de memoria (puntero) que dice: "El objeto real est√° en el Heap en la direcci√≥n 0x55A...".
    El "Return Address": La instrucci√≥n de a d√≥nde debe volver el control del programa cuando esta funci√≥n termine.

3. ¬øContexto Global vs. Contexto de Funci√≥n?

S√≠, se guardan en la misma estructura (la Pila), pero en niveles diferentes.
    Contexto Global (M√≥dulo): Es el primer plato que se pone en la mesa. Es el "Frame base".
        Contiene las variables definidas fuera de cualquier funci√≥n.
        Este Frame nunca muere (nunca se hace pop) hasta que el programa termina por completo.
    Contexto de Funci√≥n: Son los platos que se apilan encima.
        Nacen cuando llamas a la funci√≥n.
        Mueren inmediatamente cuando la funci√≥n hace return.

4. Visualizaci√≥n del Proceso: "Todo es un Objeto"

Vamos a ver c√≥mo interact√∫a el Stack con el Heap usando tu duda sobre las referencias.

Imagina este c√≥digo simple:

Aqu√≠ tienes la explicaci√≥n detallada de la Pila de Ejecuci√≥n (Call Stack) en Python.
1. ¬øQu√© es el Stack realmente? (El Algoritmo LIFO)

Imagina una pila de platos sucios en un restaurante.
    El Algoritmo: Es LIFO (Last In, First Out - √öltimo en entrar, Primero en salir).
    Solo puedes poner un plato nuevo encima del anterior (PUSH).
    Solo puedes lavar (sacar) el plato que est√° arriba de todo (POP).

En Python, cada "plato" es un Frame (Marco de Ejecuci√≥n).
2. ¬øQu√© hay dentro de cada "Plato" (Frame)?

Cada vez que llamas a una funci√≥n, Python crea un Frame nuevo y lo pone en el tope de la pila. Ese Frame es un espacio aislado que contiene:

    Las Variables Locales (Nombres): Aqu√≠ est√°n los nombres que definiste dentro de la funci√≥n (ej: summation, nums, f).
    Las Referencias (Las Flechas): Aqu√≠ es donde entra tu duda. En el Stack NO se guardan los objetos.
        Si tienes x = [1, 2], el Stack guarda el nombre x y una direcci√≥n de memoria (puntero) que dice: "El objeto real est√° en el Heap en la direcci√≥n 0x55A...".
    El "Return Address": La instrucci√≥n de a d√≥nde debe volver el control del programa cuando esta funci√≥n termine.

3. ¬øContexto Global vs. Contexto de Funci√≥n?

S√≠, se guardan en la misma estructura (la Pila), pero en niveles diferentes.

    Contexto Global (M√≥dulo): Es el primer plato que se pone en la mesa. Es el "Frame base".
        Contiene las variables definidas fuera de cualquier funci√≥n.
        Este Frame nunca muere (nunca se hace pop) hasta que el programa termina por completo.

    Contexto de Funci√≥n: Son los platos que se apilan encima.
        Nacen cuando llamas a la funci√≥n.
        Mueren inmediatamente cuando la funci√≥n hace return.

4. Visualizaci√≥n del Proceso: "Todo es un Objeto"

Vamos a ver c√≥mo interact√∫a el Stack con el Heap usando tu duda sobre las referencias.

Imagina este c√≥digo simple:

Paso A: Inicio (Contexto Global)
Python inicia.
    Crea el objeto int(10) en el Heap.
    Crea el Global Frame en el Stack.
    En ese Frame, escribe el nombre a y le asigna la referencia al objeto 10.

Paso B: Llamada a saludo() (PUSH)

Se llama a la funci√≥n.

    PUSH: Python crea un nuevo Frame para saludo y lo pone encima del Global Frame.
    Ahora el "foco" de ejecuci√≥n est√° arriba. El Global Frame queda "congelado" abajo.
    Dentro del Frame de saludo:
        Se crea el objeto str("Hola") en el Heap.
        Se escribe el nombre texto en el Stack (Frame saludo) con la referencia al "Hola".

Paso C: Retorno (POP)

La funci√≥n termina (return texto).
    Devuelve la referencia del objeto "Hola" a quien lo llam√≥.
    POP: El Frame de saludo se destruye.
        ¬°Ojo! La variable texto (el nombre) desaparece.
        Pero el objeto "Hola" en el Heap sigue existiendo si alguien m√°s lo atrap√≥. Si nadie lo atrap√≥, pasa el basurero (Garbage Collector) y lo borra.

---------------------------------------------------------------------------------------------------------------------
Funciones de orden superior.

    -Una funci√≥n puede tomar una o m√°s funciones como par√°metros
    -Una funci√≥n puede ser devuelta como resultado de otra funci√≥n
    -Una funci√≥n puede ser modificada
    -Una funci√≥n puede ser asignada a una variable

En esta secci√≥n cubriremos:

    -Funciones de manejo como par√°metros
    -Devoluci√≥n de funciones como valor de retorno de otras funciones
    -Uso de cierres y decoradores de Python

Funcionar como un par√°metro:

def sum_numbers(nums):  # normal function
    return sum(nums)    # a sad function abusing the built-in sum function :<

def higher_order_function(f, lst):  # function as a parameter
    summation = f(lst)
    return summation

result = higher_order_function(sum_numbers, [1, 2, 3, 4, 5])
print(result)       # 15

1. La Divisi√≥n Principal: Stack vs. Heap

    (STACK / Pila): Es la zona de "ejecuci√≥n ordenada". 
        Aqu√≠ se apilan los contextos (Frames) de las funciones que est√°n corriendo. 
        Es temporal; cuando la funci√≥n termina (hace return), su cuadro desaparece (POP).
    (HEAP / Mont√≥n): Es la zona de "almacenamiento". 
    Aqu√≠ viven los Objetos reales. 
    En Python, todo es un objeto (n√∫meros, listas y funciones). 
    Los datos aqu√≠ persisten mientras alguien los necesite.

2. El Flujo Paso a Paso (Siguiendo las flechas)

A. El Global Frame (Inicio)
En la parte inferior del Stack ves el Global Frame.
    Python lee tu c√≥digo y crea dos objetos de tipo function en el Heap: 
        -Func1 (sum_numbers)
        -Func2 (higher_order_function).
    Las variables sum_numbers y higher_order_function en el Stack son solo etiquetas (flechas) que apuntan a esos objetos en el Heap.

B. La llamada a higher_order_function (Frame del Medio)
Cuando ejecutas result = higher_order_function(...), se crea un nuevo cuadro en el Stack. 
Aqu√≠ ocurre la magia del "Funcionar como par√°metro":
    El par√°metro f: F√≠jate en la flecha que sale de f. 
    Apunta exactamente al mismo objeto que sum_numbers.
        No se cre√≥ una copia de la funci√≥n.
        Simplemente, f es un nuevo nombre temporal para referirse a la l√≥gica de sum_numbers.
    El par√°metro lst: Apunta al objeto List1 en el Heap ([1, 2, 3...]).

C. La ejecuci√≥n interna sum_numbers (Frame Superior)
Dentro de la funci√≥n de orden superior, llamamos a f(lst). 
    Como f es sum_numbers, se abre un nuevo cuadro arriba del todo:
    El par√°metro nums: Observa que la flecha de nums va al mismo objeto List1 que lst. 
    Python no duplic√≥ la lista, solo pas√≥ la referencia (direcci√≥n de memoria).
    El c√°lculo: La funci√≥n suma los valores y crea un nuevo objeto entero en el Heap (Int1 con valor 15).

3. Conclusiones Clave de la Imagen
    Las funciones son datos: En el Heap, ves que Func1 y Func2 ocupan espacio igual que la lista List1. 
    Esto demuestra que para Python, una funci√≥n es un objeto m√°s que se puede pasar de mano en mano.
    Referencias (Las Flechas): El Stack no guarda los datos pesados (como la lista completa o el c√≥digo de la funci√≥n), solo guarda "direcciones" o punteros para saber d√≥nde encontrarlos en el Heap.
    Aliasing: sum_numbers (en Global) y f (en local) son dos nombres distintos para el mismo objeto Func1.


---------------------------------------------------------------------------------------------------------------------
Funcionar como un valor de retorno.
def square(x):          # a square function
    return x ** 2

def cube(x):            # a cube function
    return x ** 3

def absolute(x):        # an absolute value function
    if x >= 0:
        return x
    else:
        return -(x)

def higher_order_function(type): # a higher order function returning a function
    if type == 'square':
        return square
    elif type == 'cube':
        return cube
    elif type == 'absolute':
        return absolute

result = higher_order_function('square')
print(result(3))       # 9
result = higher_order_function('cube')
print(result(3))       # 27
result = higher_order_function('absolute')
print(result(-3))      # 3

1. Funciones como "Ciudadanos de Primera Clase"
En Python, las funciones son objetos. 
Cuando escribes square (sin par√©ntesis), no est√°s ejecutando nada; 
est√°s haciendo referencia a la direcci√≥n de memoria donde vive el c√≥digo de esa funci√≥n en el Heap.
    square: Es el objeto funci√≥n (el "control remoto").
    square(3): Es la ejecuci√≥n de la funci√≥n (el "bot√≥n presionado").

2. ¬øEs esto Polimorfismo?
S√≠, absolutamente. En el sentido m√°s puro, el polimorfismo es la capacidad de algo para tomar m√∫ltiples formas.
En tu c√≥digo, la variable result es polim√≥rfica:
    En una l√≠nea, result apunta a la l√≥gica de x2.
    En otra, apunta a la l√≥gica de x3.
    La interfaz es la misma: T√∫ siempre llamas a result(3). No te importa qu√© hay adentro, solo sabes que "se puede llamar".

    Dato Clave: En programaci√≥n orientada a objetos (POO), el polimorfismo suele hacerse con clases y herencia. 
    En Python, gracias al Duck Typing ("si camina como pato y suena como pato..."), 
    el polimorfismo es mucho m√°s natural: si un objeto tiene el m√©todo __call__ (es decir, se puede llamar), Python lo trata como una funci√≥n y listo.

Esta t√©cnica se usa constantemente para:
    Configuraci√≥n din√°mica: Elegir un algoritmo de ordenamiento seg√∫n el tama√±o de los datos.
    Decoradores: Modificar el comportamiento de una funci√≥n envolvi√©ndola en otra.
    Callbacks: Decirle a un bot√≥n: "No s√© qu√© vas a hacer cuando te presionen, pero aqu√≠ tienes la funci√≥n que debes ejecutar".

---------------------------------------------------------------------------------------------------------------------

Entender c√≥mo funciona este c√≥digo requiere visualizar el concepto de Closure (Cierre) y c√≥mo Python maneja los √°mbitos (scopes) de las variables.

Aqu√≠ tienes la explicaci√≥n detallada del proceso y el algoritmo de b√∫squeda que utiliza Python.
El Algoritmo: Regla LEGB

Para alcanzar cada valor, Python aplica un algoritmo de b√∫squeda llamado LEGB. Cuando el programa encuentra un nombre (como ten o num), busca en este orden estricto:

    L (Local): Dentro de la funci√≥n actual.

    E (Enclosing): En el √°mbito de las funciones que envuelven a la actual (aqu√≠ es donde ocurre la magia del closure).

    G (Global): En el nivel superior del archivo/m√≥dulo.

    B (Built-in): Nombres preinstalados en Python (como print o len).

Paso a Paso: El viaje de la memoria
1. La llamada add_ten() (Creaci√≥n del Closure)

    Se crea un Frame en el Stack para add_ten.

    Se crea la variable ten = 10 dentro de ese Frame.

    Se define la funci√≥n interna add. En este momento, Python nota que add necesita la variable ten de su "padre".

    La Clave: Aunque add_ten termina y su Frame deber√≠a desaparecer del Stack (hacer POP), Python mueve la variable ten a un lugar especial en el Heap vinculado a la funci√≥n add. Esto es el Closure.

    closure_result ahora es una referencia a esa funci√≥n add que "lleva puesta una mochila" con el valor 10.

2. La llamada closure_result(5)

    Se crea un nuevo Frame para add.

    B√∫squeda de num: Python aplica LEGB. Lo encuentra inmediatamente en L (Local) porque es el argumento (valor 5).

    B√∫squeda de ten:

        Busca en L (Local): No est√°.

        Busca en E (Enclosing): ¬°Lo encuentra! Es el valor 10 que qued√≥ guardado en el closure.

    Suma 5+10 y retorna 15.

3. La llamada closure_result(10)

    Se repite el mismo proceso.

    num se encuentra en Local como 10.

    ten se vuelve a encontrar en Enclosing como 10.

    Suma 10+10 y retorna 20.

Visualizaci√≥n del Mapa de Memoria

Para este caso espec√≠fico, el mapa se ver√≠a as√≠:

    Global Frame: Contiene el nombre closure_result apuntando al objeto funci√≥n en el Heap.

    Heap: El objeto funci√≥n add tiene un atributo oculto (__closure__) que mantiene una referencia al objeto int(10).

    Stack: Cada vez que llamas a closure_result(), aparece un Frame temporal para la ejecuci√≥n que desaparece al terminar, pero el valor ten permanece en el Heap mientras la funci√≥n exista.

Buen√≠sima pregunta, porque la imagen confunde a mucha gente si no se entiende qu√© est√° mostrando el visualizador (tipo Python Tutor). Vamos por partes y con precisi√≥n t√©cnica.

1Ô∏è‚É£ ¬øPor qu√© en el Global frame aparecen add_ten y closure_result ‚Äúdentro del mismo recuadro‚Äù?
üîπ Qu√© representa el Global frame

El Global frame es un solo frame, no varios.

Ese recuadro representa:

El namespace global del programa (el diccionario globals())

Todo lo que se define al nivel del archivo vive ah√≠:
add_ten = <function>
closure_result = <function>

Por eso en la imagen ves:
Global frame
‚îú‚îÄ‚îÄ add_ten
‚îî‚îÄ‚îÄ closure_result

üëâ No significa que est√©n relacionados l√≥gicamente, solo que:

Comparten el mismo √°mbito

Est√°n almacenados en el mismo diccionario global

T√©cnicamente:


globals() == {
    'add_ten': <function add_ten>,
    'closure_result': <function add>
}

üîπ Por qu√© parecen ‚Äúal mismo nivel visual‚Äù

El visualizador dibuja frames como cajas, no como pila de llamadas:

Un frame = un entorno de variables

El global frame siempre existe

No se destruye nunca mientras el programa corre

Por eso:

add_ten y closure_result est√°n en el mismo recuadro

No hay jerarqu√≠a entre ellos

Son nombres distintos apuntando a objetos distintos

2Ô∏è‚É£ Entonces‚Ä¶ ¬øqu√© es la flecha hacia add(num) [parent=f1]?

Esa flecha indica referencia a un objeto funci√≥n, no ejecuci√≥n.

closure_result ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∂ function add(num) [parent=f1]

Significa:

closure_result apunta al objeto funci√≥n add

Ese objeto funci√≥n tiene un entorno padre (parent=f1)

Ese parent=f1 es la clave del cierre.

3Ô∏è‚É£ ¬øC√≥mo se busca el valor de ten? (parte m√°s importante)

Vamos paso a paso, exactamente como lo hace Python.

C√≥digo ejecutado:

return num + ten

üîç Resoluci√≥n de nombres (LEGB)

Python busca ten usando esta regla:

L ‚Äì Local ‚Üí ¬øten est√° en el frame de add?

FRAME add
‚îî‚îÄ‚îÄ num = 5

‚ùå No

E ‚Äì Enclosing ‚Üí ¬øten est√° en el entorno envolvente?
‚úîÔ∏è S√≠

Pero ojo:
üëâ ese entorno NO es el frame de add_ten, porque ese frame ya fue destruido.

4Ô∏è‚É£ Entonces, ¬ød√≥nde est√° realmente ten?
üîπ Est√° en una closure cell

Cuando Python crea la funci√≥n add, detecta que:

ten no es local

No es global

Es una variable libre

Entonces crea una cell object.

Conceptualmente:
function add
‚îú‚îÄ‚îÄ __closure__
‚îÇ    ‚îî‚îÄ‚îÄ cell ‚îÄ‚îÄ‚ñ∂ 10
‚îî‚îÄ‚îÄ code object
El parent=f1 en la imagen representa:

‚ÄúEsta funci√≥n tiene acceso a un entorno envolvente preservado‚Äù

5Ô∏è‚É£ B√∫squeda real de ten en tiempo de ejecuci√≥n

Cuando llam√°s:
closure_result(5)

Python hace:

Frame actual
FRAME add
‚îî‚îÄ‚îÄ num = 5

Resoluci√≥n de ten

    Local ‚Üí ‚ùå

    Enclosing ‚Üí ‚úîÔ∏è

    Busca en add.__closure__

    Encuentra la cell

    Extrae cell_contents = 10

num + ten
5   + 10 = 15

6Ô∏è‚É£ Por qu√© la flecha va de add a add(num) [parent=f1]

Esa flecha NO significa llamada, significa:

El objeto funci√≥n add mantiene una referencia a su entorno l√©xico

Es una relaci√≥n estructural, no din√°mica.

7Ô∏è‚É£ Resumen visual simplificado

GLOBAL FRAME
‚îú‚îÄ‚îÄ add_ten ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∂ function
‚îî‚îÄ‚îÄ closure_result ‚îÄ‚îÄ‚ñ∂ function add
                         ‚îÇ
                         ‚îî‚îÄ‚îÄ __closure__
                              ‚îî‚îÄ‚îÄ cell ‚Üí 10

Cada llamada crea:

FRAME add
‚îî‚îÄ‚îÄ num ‚Üí valor

8Ô∏è‚É£ Frase t√©cnica clave (para que te quede claro)

ten no se busca en el global frame ni en un frame activo, sino en una closure cell asociada al objeto funci√≥n, la cual preserva el entorno l√©xico de la funci√≥n envolvente.
------------------------------- idem anterior
Entender c√≥mo funciona este c√≥digo requiere visualizar el concepto de Closure (Cierre) y c√≥mo Python maneja los √°mbitos (scopes) de las variables.

Aqu√≠ tienes la explicaci√≥n detallada del proceso y el algoritmo de b√∫squeda que utiliza Python.
El Algoritmo: Regla LEGB

Para alcanzar cada valor, Python aplica un algoritmo de b√∫squeda llamado LEGB. Cuando el programa encuentra un nombre (como ten o num), busca en este orden estricto:

    L (Local): Dentro de la funci√≥n actual.

    E (Enclosing): En el √°mbito de las funciones que envuelven a la actual (aqu√≠ es donde ocurre la magia del closure).

    G (Global): En el nivel superior del archivo/m√≥dulo.

    B (Built-in): Nombres preinstalados en Python (como print o len).

Paso a Paso: El viaje de la memoria
1. La llamada add_ten() (Creaci√≥n del Closure)

    Se crea un Frame en el Stack para add_ten.

    Se crea la variable ten = 10 dentro de ese Frame.

    Se define la funci√≥n interna add. En este momento, Python nota que add necesita la variable ten de su "padre".

    La Clave: Aunque add_ten termina y su Frame deber√≠a desaparecer del Stack (hacer POP), Python mueve la variable ten a un lugar especial en el Heap vinculado a la funci√≥n add. Esto es el Closure.

    closure_result ahora es una referencia a esa funci√≥n add que "lleva puesta una mochila" con el valor 10.

2. La llamada closure_result(5)

    Se crea un nuevo Frame para add.

    B√∫squeda de num: Python aplica LEGB. Lo encuentra inmediatamente en L (Local) porque es el argumento (valor 5).

    B√∫squeda de ten:

        Busca en L (Local): No est√°.

        Busca en E (Enclosing): ¬°Lo encuentra! Es el valor 10 que qued√≥ guardado en el closure.

    Suma 5+10 y retorna 15.

3. La llamada closure_result(10)

    Se repite el mismo proceso.

    num se encuentra en Local como 10.

    ten se vuelve a encontrar en Enclosing como 10.

    Suma 10+10 y retorna 20.

Visualizaci√≥n del Mapa de Memoria

Para este caso espec√≠fico, el mapa se ver√≠a as√≠:

    Global Frame: Contiene el nombre closure_result apuntando al objeto funci√≥n en el Heap.

    Heap: El objeto funci√≥n add tiene un atributo oculto (__closure__) que mantiene una referencia al objeto int(10).

    Stack: Cada vez que llamas a closure_result(), aparece un Frame temporal para la ejecuci√≥n que desaparece al terminar, pero el valor ten permanece en el Heap mientras la funci√≥n exista.

---------------------------------------------------------------------------------------------------------------------
    Decoradores de Python Un decorador es un patr√≥n de dise√±o en Python que permite a un usuario a√±adir nueva funcionalidad a un objeto existente sin modificar su estructura. Los decoradores generalmente se llaman antes de la definici√≥n de una funci√≥n que desea decorar. Creaci√≥n de decoradores Para crear una funci√≥n de decorador, necesitamos una funci√≥n externa con una funci√≥n de envoltura interna. Ejemplo: # Normal function def greeting(): return 'Welcome to Python' def uppercase_decorator(function): def wrapper(): func = function() make_uppercase = func.upper() return make_uppercase return wrapper g = uppercase_decorator(greeting) print(g()) # WELCOME TO PYTHON ## Let us implement the example above with a decorator '''This decorator function is a higher order function that takes a function as a parameter''' def uppercase_decorator(function): def wrapper(): func = function() make_uppercase = func.upper() return make_uppercase return wrapper @uppercase_decorator def greeting(): return 'Welcome to Python' print(greeting()) # WELCOME TO PYTHON Explicame de forma mas sencilla, parti de la base y anda agregando de forma sencilla para entenderlo
17:30
Decoradores de Python - Explicaci√≥n desde cero

Voy a explicarte los decoradores paso a paso, empezando desde lo m√°s b√°sico.
1Ô∏è‚É£ Concepto fundamental: Las funciones son objetos

En Python, las funciones son "ciudadanos de primera clase", lo que significa que puedes tratarlas como cualquier otra variable:
def saludar():
    return "Hola"

# Puedo guardar la funci√≥n en una variable
mi_funcion = saludar
print(mi_funcion())  # Hola

2Ô∏è‚É£ Funciones dentro de funciones
Puedes definir una funci√≥n dentro de otra funci√≥n:

def funcion_externa():
    mensaje = "Hola desde afuera"
    
    def funcion_interna():
        return "Hola desde adentro"
    
    return funcion_interna()

print(funcion_externa())  # Hola desde adentro

3Ô∏è‚É£ Retornar una funci√≥n
Aqu√≠ viene lo interesante: una funci√≥n puede retornar otra funci√≥n:
def funcion_externa():
    
    def funcion_interna():
        return "Hola"
    
    return funcion_interna  # Retorno la funci√≥n, no la ejecuto

# Guardo la funci√≥n retornada
mi_func = funcion_externa()
# Ahora la ejecuto
print(mi_func())  # Hola

4Ô∏è‚É£ Funciones que reciben funciones
Una funci√≥n puede recibir otra funci√≥n como par√°metro:

def saludar():
    return "hola mundo"

def gritar(alguna_funcion):
    # Ejecuto la funci√≥n que recib√≠
    texto = alguna_funcion()
    # La convierto a may√∫sculas
    return texto.upper()

resultado = gritar(saludar)
print(resultado)  # HOLA MUNDO

5Ô∏è‚É£ Combinando todo: El decorador b√°sico
def saludar():
    return "hola mundo"

def decorador_mayusculas(funcion_original):
    # Creo una nueva funci√≥n que "envuelve" a la original
    def envoltura():
        # Ejecuto la funci√≥n original
        resultado = funcion_original()
        # Le agrego funcionalidad (convertir a may√∫sculas)
        return resultado.upper()
    
    # Retorno la nueva funci√≥n
    return envoltura

# "Decoro" mi funci√≥n
saludar_decorado = decorador_mayusculas(saludar)
print(saludar_decorado())  # HOLA MUNDO

6Ô∏è‚É£ Usando el s√≠mbolo @ (az√∫car sint√°ctico)
El s√≠mbolo @ es solo una forma m√°s elegante de hacer lo anterior:

# En lugar de hacer esto:
# saludar_decorado = decorador_mayusculas(saludar)

# Puedes hacer esto:
@decorador_mayusculas
def saludar():
    return "hola mundo"

print(saludar())  # HOLA MUNDO
```

## üìù Resumen visual
```
Funci√≥n original: saludar() ‚Üí "hola mundo"
                    ‚Üì
Decorador la envuelve y agrega funcionalidad
                    ‚Üì
Funci√≥n decorada: saludar() ‚Üí "HOLA MUNDO"