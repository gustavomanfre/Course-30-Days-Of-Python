
######################################################################################################################################################
FOR EN COLECCIONES (LISTAS O CADENAS) 

frutas = ["ðŸŽ", "ðŸŒ", "ðŸ‡"]
for fruta in frutas:
    print(f"Hoy comerÃ©: {fruta}")

La variable fruta va tomando el valor de cada elemento de la lista automÃ¡ticamente.
________________________________________________________________________________________________________________________________________________________

FOR CON RANGE (PARA CONTAR)
Este es el mÃ¡s parecido a otros lenguajes. Se usa cuando sabes exactamente cuÃ¡ntas veces quieres que se repita algo.

# Imprime los nÃºmeros del 0 al 2
for i in range(3):
    print(f"NÃºmero: {i}") # Imprime 0, 1, 2 es decir imprime 3 numeros, range(3) genera una secuencia que empieza en 0 desde 0 hasta i-1 con i=3

________________________________________________________________________________________________________________________________________________________

FOR CON ENUMERATE (VALOR E INDICE).
A veces necesitas el objeto, pero tambiÃ©n saber en quÃ© posiciÃ³n estÃ¡ (el Ã­ndice).

nombres = ["Ana", "Luis"]
for indice, nombre in enumerate(nombres):
    print(f"PosiciÃ³n {indice}: {nombre}")
######################################################################################################################################################

######################################################################################################################################################

OPERADORES DE COMPARACION.
==       EQUAL                       x == y
!=       NOT EQUAL                   x != y
>        GREATER THAN                x > y
<        LESS THAN                   x < y
>=       GREATER THAN OR EQUAL TO    x >= y
<=       LESS THAN OR EQUAL TO       x <= y

######################################################################################################################################################

OPERADORES ARIMECTICOS
    Addition(+): a + b              #Suma: Agrega un valor a otro.
    Subtraction(-): a - b           #Resta: Quita un valor de otro.
    Multiplication(*): a * b        #Calcula el producto. Ejemplo: 3 * 4
    Division(/): a / b              #Divide el primer nÃºmero por el segundo.
    Modulus(%): a % b               #MÃ³dulo (%): Devuelve el residuo o lo que sobra de la divisiÃ³n. Ejemplo: 7 % 2
    Floor division(//): a // b      #DivisiÃ³n de piso (//): Realiza la divisiÃ³n y descarta la parte decimal, devolviendo solo el nÃºmero entero hacia abajo
    Exponentiation(**): a ** b      #Eleva el primer nÃºmero a la potencia del segundo. 2 ** 3 es lo mismo que 23 (2Ã—2Ã—2), lo que resulta en 8.

######################################################################################################################################################
OPERADOR "==" E "IS"
En Python, "==" e "is" se usan para comparar, operan en niveles diferentes de la realidad de un programa.

    -Operador == (Igualdad) ðŸ’°: Compara los valores (el contenido) de los objetos.
    -Operador is (Identidad) ðŸ†”: Compara la identidad u ubicaciÃ³n en memoria. 
     Se pregunta: "Â¿Estas dos variables apuntan exactamente al mismo objeto fÃ­sico en la memoria RAM?".
     AquÃ­ Python revisa la identidad (su lugar en la memoria).
######################################################################################################################################################

######################################################################################################################################################
FUNCION LEN()
La funciÃ³n len() devuelve un nÃºmero entero que representa la cantidad de elementos presentes en un objeto.

El mÃ©todo interno __len__ es lo que se conoce en Python como un mÃ©todo mÃ­stico o dunder method (debido al doble guion bajo: Double UNDERscore). 
Es el mecanismo que permite que tus propios objetos se comporten como las colecciones nativas de Python.

Cuando llamas a la funciÃ³n integrada len(objeto), Python no calcula la longitud por sÃ­ mismo desde fuera. 
En su lugar, busca y ejecuta el mÃ©todo __len__ que estÃ¡ definido dentro de la clase de ese objeto.

Tipo de retorno: El mÃ©todo __len__ debe devolver obligatoriamente un nÃºmero entero (int) no negativo. 
Si devuelves otro tipo de dato, Python lanzarÃ¡ un TypeError.

Vamos a describir el camino de la llamada (cÃ³mo Python encuentra la funciÃ³n) y la implementaciÃ³n (cÃ³mo la funciÃ³n obtiene el dato).

1. El Ãmbito (Scope) ðŸ”
Como bien dices, len es una funciÃ³n built-in (integrada). Cuando la invocas:
    -Python busca el nombre len en el Ã¡mbito Local (tu funciÃ³n actual).
    -Si no lo encuentra, busca en el Ã¡mbito Global (tu archivo .py).
    -Finalmente, llega al Ã¡mbito de los Built-ins. AquÃ­ es donde vive la funciÃ³n len que se carga al iniciar el intÃ©rprete de Python.

2. La FunciÃ³n Built-in len() âš™ï¸
Una vez que Python encuentra la funciÃ³n en el mÃ³dulo de funciones integradas, la ejecuta pasÃ¡ndole tu objeto como argumento. 
Pero aquÃ­ estÃ¡ el detalle tÃ©cnico: len() es una funciÃ³n escrita en C (en la implementaciÃ³n estÃ¡ndar CPython). 
No "cuenta" los elementos manualmente desde fuera; su cÃ³digo interno estÃ¡ diseÃ±ado para pedirle esa informaciÃ³n al objeto.

3. El Protocolo del Objeto (Dunder Method) ðŸ¤

AquÃ­ es donde entra lo que mencionÃ© anteriormente. La funciÃ³n len() hace lo siguiente:
    -Verifica si el objeto tiene un mÃ©todo llamado __len__.
    -Si lo tiene, lo ejecuta: objeto.__len__().
    -Si el objeto es una colecciÃ³n nativa (como una lista o un string), este valor ya estÃ¡ guardado en una estructura de memoria en C, por lo que la respuesta es instantÃ¡nea.

El Camino Completo en Resumen:

    -Escribes len(mi_lista).
    -Python (Ãmbitos): "Busco len... no es local... no es global... Â¡ah, aquÃ­ estÃ¡ en built-ins!".
    -FunciÃ³n len: "Hola mi_lista, Python me pidiÃ³ tu longitud. Por favor, ejecuta tu mÃ©todo __len__ y dame el resultado".
    -mi_lista: "Tengo 5 elementos. AquÃ­ tienes el 5".
    -FunciÃ³n len: Devuelve el 5 a tu cÃ³digo.

######################################################################################################################################################
CASTEO DE DATOS.

El "casteo" o conversiÃ³n de tipos en Python es el proceso de transformar el valor de una variable de un tipo de dato a otro. 
A diferencia de otros lenguajes, en Python esto se hace utilizando las funciones constructoras de los tipos de datos bÃ¡sicos.

Las Funciones de ConversiÃ³n Principales ðŸ§¬

Python tiene funciones integradas para los tipos de datos mÃ¡s comunes:

FunciÃ³n     DescripciÃ³n                                              Ejemplo
int()       Convierte a un nÃºmero entero.,                          "int(""10"") âž¡ï¸ 10"
float()     Convierte a un nÃºmero de punto flotante (decimal).      float(5) âž¡ï¸ 5.0
str()       Convierte cualquier objeto en una cadena de texto.      "str(100) âž¡ï¸ ""100"""
bool()      Convierte a un valor booleano (True o False).           bool(1) âž¡ï¸ True

El proceso de "casteo" o conversiÃ³n de tipos ocurre cuando el intÃ©rprete de Python intenta transformar una representaciÃ³n de datos en otra utilizando una funciÃ³n constructora.

En Python, los tipos de datos bÃ¡sicos como int, str o float no son simples etiquetas, sino clases predefinidas que se cargan automÃ¡ticamente al iniciar el intÃ©rprete desde el mÃ³dulo builtins.
Cuando haces un "casteo", estÃ¡s realizando una instanciaciÃ³n: creas un nuevo objeto de esa clase. 
Vamos a profundizar en ese camino interno que mencionaste, especÃ­ficamente en dÃ³nde viven esas declaraciones y cÃ³mo se decide si el proceso tiene Ã©xito. ðŸ§­

1. Â¿DÃ³nde estÃ¡n declaradas estas clases? ðŸ—ï¸
Estas clases estÃ¡n declaradas en el nÃºcleo de Python (escrito mayoritariamente en C para la implementaciÃ³n estÃ¡ndar CPython).
    -MÃ³dulo builtins: Todas las funciones y clases fundamentales como int(), list() o dict() residen aquÃ­. No necesitas importarlas porque Python las pone en el Ã¡mbito global por defecto.
    -C-API de Python: Internamente, el constructor de int apunta a una estructura en C llamada PyInt_Type (o PyLong_Type en Python 3), que define cÃ³mo se debe crear ese objeto desde diferentes tipos de entrada.

2. El Protocolo de ConversiÃ³n (El "Contrato") ðŸ¤
El constructor no solo "mira" el dato, sino que busca mÃ©todos especiales dentro del objeto que le pasas.
    -Si intentas int(objeto), Python busca si objeto tiene un mÃ©todo llamado __int__.
    -Si intentas str(objeto), busca el mÃ©todo __str__.
Esto permite que la "VerificaciÃ³n de Compatibilidad" que mencionaste sea muy flexible: el objeto de origen es el que suele saber cÃ³mo convertirse al tipo de destino.

3. La Memoria: Inmutabilidad en AcciÃ³n ðŸ§Š
Un detalle tÃ©cnico crucial es que los tipos bÃ¡sicos en Python son inmutables.
    -Cuando haces y = int("45"), Python no transforma la cadena "45".
    -En su lugar, la cadena original permanece intacta y se crea un objeto completamente nuevo en una direcciÃ³n de memoria diferente para el entero 45.

Tipos de ConversiÃ³n ðŸ”„
Existen dos formas en las que esto sucede:

    -ConversiÃ³n ImplÃ­cita (CoerciÃ³n): Python lo hace automÃ¡ticamente para evitar pÃ©rdida de datos. Por ejemplo, si sumas un entero y un flotante (5 + 2.0), Python convierte el 5 en 5.0 internamente.
    -ConversiÃ³n ExplÃ­cita (Casting): Es cuando tÃº fuerzas el cambio usando las funciones que mencionamos antes (str(), int(), etc.).

######################################################################################################################################################