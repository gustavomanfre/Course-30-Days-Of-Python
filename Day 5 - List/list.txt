Listas
Hay cuatro tipos de datos de recolección en Python:
    -Lista: es una colección ORDENADA, MUTABLE (modificar). Permite  DUPLICADOS.
    -Tupla: es una colección ORDENADA, INMUTABLE (no modificable) Permite  DUPLICADOS.
    -Set:   es una colección ORDENADA, INMUTABLE (no modificable). NO Permiten  DUPLICADOS. NO INDEXADA  pero podemos agregar nuevos elementos al conjunto. 
    -Diccionario: colección  ORDENADA, MUTABLE (modificar) NO Permiten  DUPLICADOS. INDEXADA. NO Permiten  DUPLICADOS.

__________________________________________________________________________________________________________________________________________________________________________________
Gestión de Memoria y Desempaquetado en Python: Un Análisis de Bajo Nivel

En Python (específicamente en su implementación estándar, CPython), la manipulación de listas y variables implica una interacción compleja entre el Stack (pila) y el Heap (montón). A continuación, analizamos qué sucede internamente al ejecutar operaciones de asignación y desempaquetado.
1. Estructura de la Lista en Memoria
lst = ['item1', 'item2', 'item3', 'item4', 'item5']

En el Stack: La variable lst no es el objeto en sí, sino una referencia (puntero) que apunta a la dirección de memoria inicial de un objeto PyListObject ubicado en el Heap.
En el Heap: El objeto list es una estructura compleja que contiene:
    Metadatos: Contador de referencias, el tipo de objeto y, crucialmente, el tamaño de la lista.
    Bloque de Memoria Contiguo (Objeto Array): Este bloque almacena punteros, no los strings directamente. Python es un lenguaje de "referencias a objetos".
    Aritmética de Direcciones: lst[0] se localiza en la dirección base del array. Para acceder a lst[1], Python calcula la dirección sumando un offset (desplazamiento) proporcional al tamaño del puntero (normalmente 8 bytes en sistemas de 64 bits).
    Aritmética de punteros: Cuando pides lst[2], Python hace: Dirección_Base_Punteros + (2 * 8 bytes) (en sistemas de 64 bits). Lee los 8 bytes de esa dirección, encuentra 0x103 y te lleva al objeto 'item3'.

2. El Proceso de Desempaquetado (Unpacking)
first_item, second_item, third_item, *rest = lst

Variables Individuales (first_item, etc.): Estas variables se crean en el Stack. 
A diferencia de lo que se cree comúnmente, first_item no apunta a la lista, sino que apunta directamente al objeto String ('item1') que reside en el Heap. 
Python copia la dirección de memoria que estaba guardada en lst[0] y la asigna a first_item.

El operador *rest (Extended Iterable Unpacking):
    Python identifica los elementos sobrantes (índices 3 y 4).
    Se crea un nuevo objeto list independiente en el Heap.
    Shallow Copy (Copia Superficial): Python copia los punteros (direcciones de memoria) de los objetos 'item4' e 'item5' desde la lista original hacia la nueva lista rest. No se duplican los strings en memoria; tanto lst como rest comparten los mismos objetos finales.
    Contador de Referencias (Reference Counting): El objeto 'item4' ahora tiene 2 referencias: una desde lst[3] y otra desde rest[0]. El objeto no se borrará de la memoria mientras este contador sea mayor a 0.

3. Acceso y Desreferenciación

Los corchetes [] activan el método interno __getitem__. A bajo nivel, esto ejecuta una operación de desreferenciación:
    Calcula la posición del puntero mediante aritmética: Base + (índice * tamaño_puntero).
    Lee la dirección de memoria almacenada en esa posición.
    Accede al objeto final (el String) y lo devuelve.

4. Diferencia en la Salida (Print)

Es importante notar la diferencia técnica al imprimir:
    print(rest): Llama al método __repr__ del objeto lista, mostrando una representación humana de los elementos que contiene: ['item4', 'item5']. (Nota: En Python, print nunca muestra la dirección de memoria por defecto a menos que el objeto no tenga definida una representación).
    print(*rest): Aquí el asterisco actúa como un operador de desempaquetado en la función. Pasa cada elemento de la lista como un argumento independiente a print(), resultando en: item4 item5 (sin corchetes ni comas).

# Diferencia entre el operador + y el método .extend().
__________________________________________________________________________________________________________________________________________________________________________________
1. El Operador + (Concatenación: Crea algo nuevo)

Cuando haces lista3 = lista1 + lista2, Python se comporta como un arquitecto que construye un edificio nuevo desde cero.

    En la Memoria (Heap): Python crea un tercer objeto list totalmente nuevo.

    Proceso:

        Calcula el tamaño total necesario (len1+len2).

        Reserva un nuevo bloque de memoria contiguo.

        Copia los punteros de lista1 y luego los de lista2 al nuevo bloque.

    Estado final: Las listas originales (lista1 y lista2) permanecen intactas en sus direcciones de memoria originales.

2. El Método .extend() (Mutación: Modifica el original)

Cuando haces lista1.extend(lista2), Python actúa como un equipo de remodelación que añade una extensión a un edificio existente.

    En la Memoria (Heap): No se crea una lista nueva para el resultado. Se modifica el objeto lista1 directamente (in-place).

    Proceso:

        Python revisa si el bloque de memoria actual de lista1 tiene espacio libre (las listas suelen tener un pequeño margen extra).

        Si no hay espacio, Python redimensiona el bloque original de lista1 (lo hace más grande).

        Copia los punteros de lista2 al final del bloque de lista1.

    Estado final: lista1 ahora apunta a un bloque más grande que contiene los elementos de ambos. lista2 no cambia.
__________________________________________________________________________________________________________________________________________________________________________________

# CASO 1: Mutación (In-place)
edades = [20, 10, 30]
edades.sort() 
# La dirección de memoria de 'edades' es la misma, pero el orden cambió.

# CASO 2: Nueva creación
edades = [20, 10, 30]
nueva_lista = sorted(edades)
# 'edades' sigue siendo [20, 10, 30] en su sitio original.
# 'nueva_lista' es un objeto totalmente nuevo en otra dirección.

__________________________________________________________________________________________________________________________________________________________________________________

Comprobar los artículos en una lista

Comprobar un elemento si es miembro de una lista que se utiliza en el operador. Vea el ejemplo a continuación.

fruits = ['banana', 'orange', 'mango', 'lemon']
does_exist = 'banana' in fruits
print(does_exist)  # True
does_exist = 'lime' in fruits
print(does_exist)  # False

__________________________________________________________________________________________________________________________________________________________________________________